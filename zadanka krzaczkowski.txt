5.2.1
#include <stdio.h>
#include <wchar.h>

// wersja 1 — dla char
void wyczysc(char tab[]) {
    tab[0] = '\0'; // pusty napis
}

// wersja 2 — dla wchar_t
void wyczysc_w(wchar_t tab[]) {
    tab[0] = L'\0'; // pusty napis (szeroki znak)
}

int main() {
    char napis1[20] = "przykladowy tekst";
    wchar_t napis2[20] = L"drugi tekst";

    printf("Przed: \"%s\"\n", napis1);
    wyczysc(napis1);
    printf("Po:    \"%s\"\n\n", napis1);

    wprintf(L"Przed: \"%ls\"\n", napis2);
    wyczysc_w(napis2);
    wprintf(L"Po:    \"%ls\"\n", napis2);

    return 0;
}




5.2.2
#include <stdio.h>     // do printf
#include <wchar.h>     // do wchar_t i wprintf

// Funkcja do liczenia długości napisu typu char
int dlugosc(char tekst[]) {
    int i = 0;
    while (tekst[i] != '\0') {
        i++;
    }
    return i;
}

// Funkcja do liczenia długości napisu typu wchar_t
int dlugosc_w(wchar_t tekst[]) {
    int i = 0;
    while (tekst[i] != L'\0') {
        i++;
    }
    return i;
}

int main() {
    char napis1[50] = "Ala ma kota";          // napis typu char
    wchar_t napis2[50] = L"Kot ma mleko";     // napis typu wchar_t

    int d1 = dlugosc(napis1);        // długość char
    int d2 = dlugosc_w(napis2);      // długość wchar_t

    printf("Dlugosc (char): %d\n", d1);
    wprintf(L"Dlugosc (wchar_t): %d\n", d2);

    return 0;
}



5.2.3
#include <stdio.h>
#include <wchar.h>
#include <locale.h> // do setlocale

// porównuje dwa napisy typu char
int porownaj(char t1[], char t2[]) {
    int i = 0;
    while (t1[i] != '\0' || t2[i] != '\0') {
        if (t1[i] != t2[i]) {
            return 0;
        }
        i++;
    }
    return 1;
}

// porównuje dwa napisy typu wchar_t
int porownaj_w(wchar_t t1[], wchar_t t2[]) {
    int i = 0;
    while (t1[i] != L'\0' || t2[i] != L'\0') {
        if (t1[i] != t2[i]) {
            return 0;
        }
        i++;
    }
    return 1;
}

int main() {
    setlocale(LC_ALL, ""); // pozwala na polskie znaki w wprintf

    char napis1[50] = "kot";
    char napis2[50] = "kot";

    wchar_t wnapis1[50] = L"pies";
    wchar_t wnapis2[50] = L"pies";

    // test zwykłych napisów
    if (porownaj(napis1, napis2)) {
        printf("Napisy (char) są równe\n");
    } else {
        printf("Napisy (char) NIE są równe\n");
    }

    // test szerokich napisów
    if (porownaj_w(wnapis1, wnapis2)) {
        wprintf(L"Napisy (wchar_t) są równe\n");
    } else {
        wprintf(L"Napisy (wchar_t) NIE są równe\n");
    }

    return 0;
}





//5.2.4
#include <stdio.h>

// Funkcja porównująca dwa napisy leksykograficznie
int porzadek(char t1[], char t2[]) {
    int i = 0;
    while (t1[i] != '\0' && t2[i] != '\0') {
        if (t1[i] < t2[i]) return 1; // t1 jest wcześniej
        if (t1[i] > t2[i]) return 0; // t2 jest wcześniej
        i++;
    }

    // Jeśli np. t1 = "ala", t2 = "alamakota" → t1 krótszy = wcześniejszy
    if (t1[i] == '\0' && t2[i] != '\0') return 1;

    // W przeciwnym przypadku — t1 nie jest wcześniej
    return 0;
}

int main() {
    char napis1[50] = "ala";
    char napis2[50] = "alamakota";

    if (porzadek(napis1, napis2)) {
        printf("Pierwszy napis jest wcześniej leksykograficznie\n");
    } else {
        printf("Pierwszy napis NIE jest wcześniej leksykograficznie\n");
    }

    return 0;
}




//5.2.5
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

// funkcja przepisująca tekst z z[] do do_[] dla char
void przepisz(char z[], char do_[]) {
    int i = 0;
    while (z[i] != '\0') {
        do_[i] = z[i];
        i++;
    }
    do_[i] = '\0'; // zakończenie napisu
}

// funkcja przepisująca tekst dla wchar_t
void przepisz_w(wchar_t z[], wchar_t do_[]) {
    int i = 0;
    while (z[i] != L'\0') {
        do_[i] = z[i];
        i++;
    }
    do_[i] = L'\0';
}

int main() {
    setlocale(LC_ALL, "");  // do poprawnego działania wprintf

    char z1[] = "kot";
    char do1[50];

    wchar_t z2[] = L"pies";
    wchar_t do2[50];

    przepisz(z1, do1);
    przepisz_w(z2, do2);

    printf("Skopiowany (char): %s\n", do1);
    wprintf(L"Skopiowany (wchar_t): %ls\n", do2);

    return 0;
}



//5.2.6
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

// wersja dla char
void kopiujn(char nap1[], char nap2[], int n) {
    int i;
    for (i = 0; i < n && nap1[i] != '\0'; i++) {
        nap2[i] = nap1[i];
    }
    nap2[i] = '\0';  // zakończenie napisu
}

// wersja dla wchar_t
void kopiujn_w(wchar_t nap1[], wchar_t nap2[], int n) {
    int i;
    for (i = 0; i < n && nap1[i] != L'\0'; i++) {
        nap2[i] = nap1[i];
    }
    nap2[i] = L'\0';
}

int main() {
    setlocale(LC_ALL, "");  // do wypisywania wchar_t

    char z1[50] = "informatyka";
    char do1[50];
    kopiujn(z1, do1, 5);
    printf("Kopia (char): %s\n", do1);  // wypisze: infor

    wchar_t z2[50] = L"programowanie";
    wchar_t do2[50];
    kopiujn_w(z2, do2, 8);
    wprintf(L"Kopia (wchar_t): %ls\n", do2);  // wypisze: programo

    return 0;
}





//5.2.7
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

// wersja dla char
void sklej(char nap1[], char nap2[], char wynik[]) {
    int i = 0;
    while (nap1[i] != '\0') {
        wynik[i] = nap1[i];
        i++;
    }

    int j = 0;
    while (nap2[j] != '\0') {
        wynik[i] = nap2[j];
        i++;
        j++;
    }

    wynik[i] = '\0';  // zakończenie napisu
}

// wersja dla wchar_t
void sklej_w(wchar_t nap1[], wchar_t nap2[], wchar_t wynik[]) {
    int i = 0;
    while (nap1[i] != L'\0') {
        wynik[i] = nap1[i];
        i++;
    }

    int j = 0;
    while (nap2[j] != L'\0') {
        wynik[i] = nap2[j];
        i++;
        j++;
    }

    wynik[i] = L'\0';
}

int main() {
    setlocale(LC_ALL, "");

    char a[50] = "Ala ma ";
    char b[50] = "kota";
    char wynik1[100];
    sklej(a, b, wynik1);
    printf("Sklejony (char): %s\n", wynik1);  // Ala ma kota

    wchar_t wa[50] = L"Programowanie ";
    wchar_t wb[50] = L"jest super";
    wchar_t wynik2[100];
    sklej_w(wa, wb, wynik2);
    wprintf(L"Sklejony (wchar_t): %ls\n", wynik2);

    return 0;
}

a jeśli chodzi o te "ala m" i "a kota" to takie cos ale robi zle i tak bo się nie da podobno
// dodaj spację tylko jeśli jej nie ma na końcu nap1 i nie ma na początku nap2
    if (i > 0 && nap1[i - 1] != ' ' && nap2[0] != ' ') {
        wynik[i] = ' ';
        i++;
    }






//5.2.8
#include <stdio.h>

void zamienNaDuze(char tekst[]) {
    int i = 0;
    while (tekst[i] != '\0') {
        if (tekst[i] >= 'a' && tekst[i] <= 'z') {
            tekst[i] = tekst[i] - 32;  // zamiana małej na dużą
        }
        i++;
    }
}

int main() {
    char zdanie[100] = "Ala ma kota i nie lubi psa";
    zamienNaDuze(zdanie);
    printf("Po zamianie: %s\n", zdanie);  // powinno dać: ALA MA KOTA I NIE LUBI PSA
    return 0;
}




//5.2.9
#include <stdio.h>

void wytnij(char tekst[], int n, int m, char wynik[]) {
    int i = n;
    int j = 0;

    while (tekst[i] != '\0' && i <= m) {
        wynik[j] = tekst[i];
        i++;
        j++;
    }

    wynik[j] = '\0';  // zakończ wynik
}

int main() {
    char napis[50] = "informatyka";
    char wynik[50];

    wytnij(napis, 2, 5, wynik);  // powinno być: "form"
    printf("Wycięty fragment: %s\n", wynik);

    return 0;
}


zadanie tak ze jak sie poda np n= 3 i m = 5 to ze wytnie liczby od wlasnie tych liczb a zostanie reszta

void usun_fragment(char tekst[], int n, int m, char wynik[]) {
    int i = 0; // indeks w oryginalnym tekście
    int j = 0; // indeks w nowym napisie

    while (tekst[i] != '\0') {
        if (i < n || i > m) {
            wynik[j] = tekst[i];
            j++;
        }
        i++;
    }

    wynik[j] = '\0'; // zakończ napis
}




5.2.10
#include <stdio.h>

void wytnij2(char nap1[], char nap2[], char wynik[]) {
    int i = 0;              // indeks w nap1
    int j = 0;              // indeks w wynik
    int found = -1;         // indeks początku nap2 w nap1
    int k;                  // pomocniczy indeks do sprawdzania

    // 1️⃣ SZUKAMY pierwszego wystąpienia nap2 w nap1
    while (nap1[i] != '\0') {
        k = 0;
        while (nap1[i + k] == nap2[k] && nap2[k] != '\0') {
            k++;
        }
        if (nap2[k] == '\0') {
            found = i;
            break;
        }
        i++;
    }

    // 2️⃣ Jeśli NIE znaleziono — przepisz cały nap1 do wynik
    if (found == -1) {
        i = 0;
        while (nap1[i] != '\0') {
            wynik[i] = nap1[i];
            i++;
        }
        wynik[i] = '\0';
        return;
    }

    // 3️⃣ Przepisz wszystko przed znalezionym nap2
    i = 0;
    while (i < found) {
        wynik[j] = nap1[i];
        i++;
        j++;
    }

    // 4️⃣ Pomijamy nap2 → skaczemy o długość nap2 (czyli k)
    i = found + k;

    // 5️⃣ Przepisujemy resztę nap1 do końca
    while (nap1[i] != '\0') {
        wynik[j] = nap1[i];
        i++;
        j++;
    }

    wynik[j] = '\0';  // zakończ napis
}




#include <stdio.h>

void wytnijzw(char nap1[], char nap2[], char wynik[]) {
    int i = 0;  // indeks w nap1
    int j = 0;  // indeks w wynik
    int k;
    int wystepuje;

    while (nap1[i] != '\0') {
        wystepuje = 0;  // zakładamy że nie występuje

        // sprawdzamy, czy nap1[i] jest w nap2
        k = 0;
        while (nap2[k] != '\0') {
            if (nap1[i] == nap2[k]) {
                wystepuje = 1;  // znalazło się
                break;
            }
            k++;
        }

        if (!wystepuje) {
            wynik[j] = nap1[i];
            j++;
        }

        i++;
    }

    wynik[j] = '\0';  // zakończenie napisu
}





//5.2.11
#include <stdio.h>

void wytnijzw(char nap1[], char nap2[], char wynik[]) {
    int i = 0;
    int j = 0;
    int k;
    int wystepuje;

    while (nap1[i] != '\0') {
        wystepuje = 0;

        k = 0;
        while (nap2[k] != '\0') {
            if (nap1[i] == nap2[k]) {
                wystepuje = 1;
                break;
            }
            k++;
        }

        if (!wystepuje) {
            wynik[j] = nap1[i];
            j++;
        }

        i++;
    }

    wynik[j] = '\0';
}

int main() {
    char nap1[] = "informatyka";
    char nap2[] = "aik";
    char wynik[100];

    wytnijzw(nap1, nap2, wynik);

    printf("Wynik: %s\n", wynik);  // powinno wypisać: "nformty"
    return 0;
}








//5.2.12
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

// wersja char
void wytnijzn(char nap1[], char nap2[], char wynik[]) {
    int i = 0, j = 0, k, wystepuje;

    while (nap1[i] != '\0') {
        wystepuje = 0;
        k = 0;
        while (nap2[k] != '\0') {
            if (nap1[i] == nap2[k]) {
                wystepuje = 1;
                break;
            }
            k++;
        }
        if (wystepuje) {
            wynik[j++] = nap1[i];
        }
        i++;
    }

    wynik[j] = '\0';
}

// wersja wchar_t
void wytnijzn_w(wchar_t nap1[], wchar_t nap2[], wchar_t wynik[]) {
    int i = 0, j = 0, k, wystepuje;

    while (nap1[i] != L'\0') {
        wystepuje = 0;
        k = 0;
        while (nap2[k] != L'\0') {
            if (nap1[i] == nap2[k]) {
                wystepuje = 1;
                break;
            }
            k++;
        }
        if (wystepuje) {
            wynik[j++] = nap1[i];
        }
        i++;
    }

    wynik[j] = L'\0';
}

int main() {
    setlocale(LC_ALL, "");

    // wersja char
    char nap1[] = "informatyka";
    char nap2[] = "aty";
    char wynik[100];
    wytnijzn(nap1, nap2, wynik);
    printf("Wynik (char): %s\n", wynik);  // powinno być "atya"

    // wersja wchar_t
    wchar_t wnap1[] = L"informatyka";
    wchar_t wnap2[] = L"aty";
    wchar_t wynik_w[100];
    wytnijzn_w(wnap1, wnap2, wynik_w);
    wprintf(L"Wynik (wchar_t): %ls\n", wynik_w);  // powinno być "atya"

    return 0;
}





//5.2.13
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

// wersja dla char
void wytnijtm(char nap1[], char nap2[], char wynik[]) {
    int i = 0, j = 0;
    while (nap1[i] != '\0' && nap2[i] != '\0') {
        if (nap1[i] != nap2[i]) {
            wynik[j] = nap1[i];
	    j++;
        }
        i++;
    }
    wynik[j] = '\0';
}

// wersja dla wchar_t
void wytnijtm_w(wchar_t nap1[], wchar_t nap2[], wchar_t wynik[]) {
    int i = 0, j = 0;
    while (nap1[i] != L'\0' && nap2[i] != L'\0') {
        if (nap1[i] != nap2[i]) {
            wynik[j++] = nap1[i];
        }
        i++;
    }
    wynik[j] = L'\0';
}

int main() {
    setlocale(LC_ALL, "");

    // test dla char
    char nap1[] = "informatyka";
    char nap2[] = "inxxmaxxxxx";
    char wynik[100];
    wytnijtm(nap1, nap2, wynik);
    printf("Wynik (char): %s\n", wynik);  // powinno być: "fortyka"

    // test dla wchar_t
    wchar_t wnap1[] = L"informatyka";
    wchar_t wnap2[] = L"inxxmaxxxxx";
    wchar_t wynik_w[100];
    wytnijtm_w(wnap1, wnap2, wynik_w);
    wprintf(L"Wynik (wchar_t): %ls\n", wynik_w);  // powinno być: "fortyka"

    return 0;
}




//5.2.14
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

// wersja dla char z użyciem bibliotecznej funkcji puts
void wypisz(char napis[]) {
    puts(napis);  // automatycznie dodaje \n
}

// wersja dla wchar_t z użyciem wprintf
void wypisz_w(wchar_t napis[]) {
    wprintf(L"%ls\n", napis);
}

int main() {
    setlocale(LC_ALL, "");

    char tekst1[] = "Witaj, świecie!";
    wchar_t tekst2[] = L"Witaj, właścicielu 🌍";

    printf("Wersja char: ");
    wypisz(tekst1);

    wprintf(L"Wersja wchar_t: ");
    wypisz_w(tekst2);

    return 0;
}


//5.2.15
#include <iostream>
#include <string>

// funkcja dla zwykłych stringów
void wypisz(std::string napis) {
    std::cout << napis << std::endl;
}

// funkcja dla szerokich stringów
void wypisz(std::wstring napis) {
    std::wcout << napis << std::endl;
}

int main() {
    std::string tekst1 = "Witaj, świecie!";
    std::wstring tekst2 = L"Witaj, właścicielu 🌍";

    std::cout << "Wersja string: ";
    wypisz(tekst1);

    std::wcout << L"Wersja wstring: ";
    wypisz(tekst2);

    return 0;
}




//5.2.16
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

// Funkcja dla zwykłych znaków
void wczytaj(char napis[], int rozmiar) {
    fgets(napis, rozmiar, stdin);  // wczytaj do tablicy char[]
}

// Funkcja dla szerokich znaków
void wczytaj_w(wchar_t napis[], int rozmiar) {
    fgetws(napis, rozmiar, stdin);  // wczytaj do tablicy wchar_t[]
}

int main() {
    setlocale(LC_ALL, "");  // umożliwia użycie polskich znaków w wchar_t

    char tekst[100];
    wchar_t wtekst[100];

    printf("Wprowadź napis (char): ");
    wczytaj(tekst, 100);

    wprintf(L"Wprowadź napis (wchar_t): ");
    wczytaj_w(wtekst, 100);

    printf("Wczytano (char): %s", tekst);
    wprintf(L"Wczytano (wchar_t): %ls", wtekst);

    return 0;
}





//5.2.17
#include <iostream>
#include <string>

// funkcja dla string
void wczytaj(std::string &napis) {
    std::getline(std::cin, napis);  // wczytuje cały wiersz do stringa
}

// funkcja dla wstring
void wczytaj(std::wstring &napis) {
    std::getline(std::wcin, napis);  // dla szerokich znaków
}

int main() {
    std::string tekst1;
    std::wstring tekst2;

    std::cout << "Wprowadź napis (string): ";
    wczytaj(tekst1);

    std::wcout << L"Wprowadź napis (wstring): ";
    wczytaj(tekst2);

    std::cout << "Wczytano (string): " << tekst1 << std::endl;
    std::wcout << L"Wczytano (wstring): " << tekst2 << std::endl;

    return 0;
}




//5.2.20
#include <stdio.h>
#include <wchar.h>
#include <locale.h>
#include <stdlib.h>

// dla char*
char* godzina(int godz, int min, int sek) {
    char* wynik = malloc(9);  // "gg:mm:ss" + '\0' = 9
    sprintf(wynik, "%02d:%02d:%02d", godz, min, sek);
    return wynik;
}

// dla wchar_t*
wchar_t* godzina_w(int godz, int min, int sek) {
    wchar_t* wynik = malloc(9 * sizeof(wchar_t));
    swprintf(wynik, 9, L"%02d:%02d:%02d", godz, min, sek);
    return wynik;
}

int main() {
    setlocale(LC_ALL, "");

    int godz = 9, min = 5, sek = 7;

    char* czas1 = godzina(godz, min, sek);
    wchar_t* czas2 = godzina_w(godz, min, sek);

    printf("Godzina (char): %s\n", czas1);
    wprintf(L"Godzina (wchar_t): %ls\n", czas2);

    free(czas1);
    free(czas2);

    return 0;
}

ALBO BEZ MALLOC

//5.2.20
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

void godzina(int godz, int min, int sek, char wynik[]) {
    sprintf(wynik, "%02d:%02d:%02d", godz, min, sek);
}

void godzina_w(int godz, int min, int sek, wchar_t wynik[]) {
    swprintf(wynik, 20, L"%02d:%02d:%02d", godz, min, sek);
}

int main() {
    setlocale(LC_ALL, "");

    char wynik1[20];
    wchar_t wynik2[20];

    godzina(9, 5, 2, wynik1);
    godzina_w(14, 7, 59, wynik2);

    printf("Godzina (char): %s\n", wynik1);
    wprintf(L"Godzina (wchar_t): %ls\n", wynik2);

    return 0;
}




//5.2.22
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <locale.h>

char* sklej(const char* nap1, const char* nap2, const char* nap3) {
    int dl = strlen(nap1) + strlen(nap2) + strlen(nap3) + 1;
    char* wynik = malloc(dl * sizeof(char));
    if (wynik == NULL) return NULL;

    strcpy(wynik, nap1);
    strcat(wynik, nap2);
    strcat(wynik, nap3);

    return wynik;
}

wchar_t* sklej_w(const wchar_t* nap1, const wchar_t* nap2, const wchar_t* nap3) {
    int dl = wcslen(nap1) + wcslen(nap2) + wcslen(nap3) + 1;
    wchar_t* wynik = malloc(dl * sizeof(wchar_t));
    if (wynik == NULL) return NULL;

    wcscpy(wynik, nap1);
    wcscat(wynik, nap2);
    wcscat(wynik, nap3);

    return wynik;
}

int main() {
    setlocale(LC_ALL, "");

    char* wynik1 = sklej("Ala", " ma ", "kota");
    if (wynik1 != NULL) {
        printf("Sklejone (char): %s\n", wynik1);
        free(wynik1);
    }

    wchar_t* wynik2 = sklej_w(L"Pies", L" lubi ", L"kota");
    if (wynik2 != NULL) {
        wprintf(L"Sklejone (wchar_t): %ls\n", wynik2);
        free(wynik2);
    }

    return 0;
}





//5.2.24
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <locale.h>

// kopiowanie napisów typu char
void kopiuj(const char napis[], char tablica[]) {
    strcpy(tablica, napis);
}

// kopiowanie napisów typu wchar_t
void kopiuj_w(const wchar_t napis[], wchar_t tablica[]) {
    wcscpy(tablica, napis);
}

int main() {
    setlocale(LC_ALL, "");

    char zrodlo1[] = "Ala ma kota";
    char cel1[50];
    kopiuj(zrodlo1, cel1);
    printf("Skopiowany (char): %s\n", cel1);

    wchar_t zrodlo2[] = L"Pies ma kota";
    wchar_t cel2[50];
    kopiuj_w(zrodlo2, cel2);
    wprintf(L"Skopiowany (wchar_t): %ls\n", cel2);

    return 0;
}





//5.2.25
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void kopiuj(const char* napis, char** wynik) {
    *wynik = (char*)malloc((strlen(napis) + 1) * sizeof(char));
    if (*wynik != NULL) {
        strcpy(*wynik, napis);
    }
}

int main() {
    const char* oryginal = "Ala ma kota";
    char* wynik = NULL;

    kopiuj(oryginal, &wynik);

    if (wynik != NULL) {
        printf("Skopiowany napis: %s\n", wynik);
        free(wynik);
    }

    return 0;
}



//5.2.26
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <wctype.h>

// wersja 1 – dla char
void zamien_na_duze(char* napis) {
    int i = 0;
    while (napis[i] != '\0') {
        napis[i] = toupper(napis[i]);
        i++;
    }
}

// wersja 2 – dla wchar_t
void zamien_na_duze_w(wchar_t* napis) {
    int i = 0;
    while (napis[i] != L'\0') {
        napis[i] = towupper(napis[i]);
        i++;
    }
}

int main() {
    char tekst1[] = "Witaj, właścicielu!";
    wchar_t tekst2[] = L"Cześć, królu kodu!";

    printf("Przed (char): %s\n", tekst1);
    zamien_na_duze(tekst1);
    printf("Po    (char): %s\n\n", tekst1);

    wprintf(L"Przed (wchar_t): %ls\n", tekst2);
    zamien_na_duze_w(tekst2);
    wprintf(L"Po    (wchar_t): %ls\n", tekst2);

    return 0;
}




//5.2.27
#include <iostream>
#include <string>
#include <locale>
#include <cwctype>

// wersja 1 – string (ASCII)
void zamien_na_duze(std::string& tekst) {
    for (char& znak : tekst) {
        if (std::islower(static_cast<unsigned char>(znak))) {
            znak = std::toupper(static_cast<unsigned char>(znak));
        }
    }
}

// wersja 2 – wstring (Unicode)
void zamien_na_duze(std::wstring& tekst) {
    for (wchar_t& znak : tekst) {
        if (iswlower(znak)) {
            znak = towupper(znak);
        }
    }
}

int main() {
    std::string napis1 = "Witaj, właścicielu!";
    std::wstring napis2 = L"Cześć, królu kodu!";

    zamien_na_duze(napis1);
    zamien_na_duze(napis2);

    std::cout << "string:  " << napis1 << "\n";
    std::wcout << L"wstring: " << napis2 << L"\n";

    return 0;
}







//6.2.1
#include <stdio.h>
#include <stdlib.h>

// Funkcja tworząca dynamiczną tablicę int[n][m]
int** utworz(int n, int m) {
    int** tab = malloc(n * sizeof(int*)); // krok 1: tworzymy n wierszy (wskaźników)
    if (tab == NULL) return NULL;

    for (int i = 0; i < n; i++) {
        tab[i] = malloc(m * sizeof(int)); // krok 2: każdy wiersz ma m kolumn
        if (tab[i] == NULL) return NULL;
    }

    return tab; // zwracamy wskaźnik do tablicy
}

int main() {
    int n = 3, m = 4;
    int** t = utworz(n, m); // wywołanie funkcji

    // Wypełnijmy ją np. wartościami rosnącymi
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            t[i][j] = i * m + j;
        }
    }

    // Wypiszmy tablicę
    printf("Zawartosc tablicy:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%3d ", t[i][j]);
        }
        printf("\n");
    }

    // Zwolnienie pamięci
    for (int i = 0; i < n; i++) {
        free(t[i]);
    }
    free(t);

    return 0;
}





//6.2.2
#include <stdio.h>
#include <stdlib.h>

// Funkcja tworzy blokową tablicę int[n][m]
int (*utworzTablice(int n, int m))[m] {
    int (*tab)[m] = malloc(n * sizeof(*tab)); // czyli: int tab[n][m]
    return tab;
}

int main() {
    int n = 3, m = 4;
    int (*tab)[m] = utworzTablice(n, m);

    // Wypełnij tablicę
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = i * m + j;

    // Wypisz
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%3d ", tab[i][j]);
        printf("\n");
    }

    free(tab); // zwolnij blok pamięci
    return 0;
}



#include <stdio.h>
#include <stdlib.h>

//6.2.3
void usunTablice(int** tab, int n, int m) {
    for (int i = 0; i < n; i++) {
        free(tab[i]);
    }
    free(tab);
}

int main() {
    int n = 3, m = 4;

    // alokacja dynamiczna tablicy n x m
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        tab[i] = malloc(m * sizeof(int));
    }

    // wypełniamy tablicę liczbami
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = i * m + j;

    // wypisujemy tablicę
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%3d ", tab[i][j]);
        printf("\n");
    }

    // usuwamy tablicę z pamięci
    usunTablice(tab, n, m);

    return 0;
}




#include <stdio.h>
#include <stdlib.h>

//6.2.4
void usunTablice(int** tab, int n, int m) {
    for (int i = 0; i < n; i++) {
        free(tab[i]);
    }
    free(tab);
}

int main() {
    int n = 2, m = 3;

    // alokacja dynamicznej tablicy n x m
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        tab[i] = malloc(m * sizeof(int));
    }

    // przykładowe wypełnienie
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = i * m + j;

    // wypisanie
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%3d ", tab[i][j]);
        printf("\n");
    }

    // usunięcie tablicy
    usunTablice(tab, n, m);

    return 0;
}





//6.2.5

#include <stdio.h>
#include <stdlib.h>

// wersja zadania 6.2.1 – tworzenie dynamicznej 3D tablicy tablic
int*** utworz3D(int n, int m, int k) {
    int*** tab = malloc(n * sizeof(int**));
    for (int i = 0; i < n; i++) {
        tab[i] = malloc(m * sizeof(int*));
        for (int j = 0; j < m; j++) {
            tab[i][j] = malloc(k * sizeof(int));
        }
    }
    return tab;
}

// wersja zadania 6.2.3 – usuwanie dynamicznej 3D tablicy tablic
void usun3D(int*** tab, int n, int m, int k) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            free(tab[i][j]);
        }
        free(tab[i]);
    }
    free(tab);
}

// test
int main() {
    int n = 2, m = 2, k = 3;
    int*** t = utworz3D(n, m, k);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            for (int l = 0; l < k; l++)
                t[i][j][l] = i + j + l;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            for (int l = 0; l < k; l++) {
                printf("%2d ", t[i][j][l]);
            }
            printf("\n");
        }
        printf("---\n");
    }

    usun3D(t, n, m, k);
    return 0;
}




//6.2.6

#include <stdio.h>
#include <stdlib.h>

// wersja 6.2.2 — utwórz 3D tablicę int
int*** utworzTablice3D(int n, int m, int k) {
    int*** tab = malloc(n * sizeof(int**));
    for (int i = 0; i < n; i++) {
        tab[i] = malloc(m * sizeof(int*));
        for (int j = 0; j < m; j++) {
            tab[i][j] = malloc(k * sizeof(int));
        }
    }
    return tab;
}

// wersja 6.2.4 — usuń 3D tablicę int
void usunTablice3D(int*** tab, int n, int m, int k) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            free(tab[i][j]);
        }
        free(tab[i]);
    }
    free(tab);
}

// test
int main() {
    int n = 2, m = 2, k = 3;
    int*** tab = utworzTablice3D(n, m, k);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            for (int l = 0; l < k; l++)
                tab[i][j][l] = i + j + l;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            for (int l = 0; l < k; l++)
                printf("%2d ", tab[i][j][l]);
            printf("\n");
        }
        printf("---\n");
    }

    usunTablice3D(tab, n, m, k);
    return 0;
}




//6.2.7

#include <stdlib.h>

// funkcja tworząca dynamiczną trójkątną tablicę tablic int
int** utworzTrojkatnaTablice(int n) {
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        tab[i] = malloc((i + 1) * sizeof(int)); // każda kolejna ma i+1 elementów
    }
    return tab;
}

// test
#include <stdio.h>
int main() {
    int n = 4;
    int** tab = utworzTrojkatnaTablice(n);

    // wypełnij wartościami
    for (int i = 0; i < n; i++)
        for (int j = 0; j <= i; j++)
            tab[i][j] = i + j;

    // wypisz
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++)
            printf("%3d", tab[i][j]);
        printf("\n");
    }

    // zwolnij pamięć
    for (int i = 0; i < n; i++)
        free(tab[i]);
    free(tab);

    return 0;
}





//6.2.8

void wyzerujTablice(int tab[][100], int n) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < 100; j++)
            tab[i][j] = 0;
}

// test
#include <stdio.h>

int main() {
    int n = 3;
    int tab[3][100];

    wyzerujTablice(tab, n);

    // wypisz kilka elementów do sprawdzenia
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 5; j++) {
            printf("%d ", tab[i][j]);
        }
        printf("\n");
    }

    return 0;
}



//6.2.9

void wyzerujDynamiczna(int** tab, int n, int m) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = 0;
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3, m = 4;
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++)
        tab[i] = malloc(m * sizeof(int));

    wyzerujDynamiczna(tab, n, m);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%d ", tab[i][j]);
        printf("\n");
    }

    for (int i = 0; i < n; i++)
        free(tab[i]);
    free(tab);

    return 0;
}





//6.2.10

void wyzeruj2D(int tab[][50], int n, int m) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = 0;
}

// test
#include <stdio.h>

int main() {
    int tab[3][50];
    int n = 3, m = 5;

    wyzeruj2D(tab, n, m);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%d ", tab[i][j]);
        printf("\n");
    }

    return 0;
}




//6.2.11

int sumaElementow(int tab[][100], int n) {
    int suma = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < 100; j++)
            suma += tab[i][j];
    return suma;
}

// test
#include <stdio.h>

int main() {
    int tab[3][100];
    int n = 3;

    // przykładowe wypełnienie
    for (int i = 0; i < n; i++)
        for (int j = 0; j < 100; j++)
            tab[i][j] = 1;

    int wynik = sumaElementow(tab, n);
    printf("Suma: %d\n", wynik);

    return 0;
}





//6.2.12

int sumaDynamiczna(int** tab, int n, int m) {
    int suma = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            suma += tab[i][j];
    return suma;
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 2, m = 3;
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++)
        tab[i] = malloc(m * sizeof(int));

    // wypełniamy jedynkami
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = 1;

    int wynik = sumaDynamiczna(tab, n, m);
    printf("Suma: %d\n", wynik);

    for (int i = 0; i < n; i++)
        free(tab[i]);
    free(tab);

    return 0;
}





//6.2.13

int sumaElementow(int** tab, int n, int m) {
    int suma = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            suma += tab[i][j];
    return suma;
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3, m = 4;
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++)
        tab[i] = malloc(m * sizeof(int));

    // wypełnienie testowe
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = 1;

    int wynik = sumaElementow(tab, n, m);
    printf("Suma: %d\n", wynik);

    for (int i = 0; i < n; i++) free(tab[i]);
    free(tab);

    return 0;
}





//6.2.14

int suma3D(int*** tab, int n, int m, int k) {
    int suma = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            for (int l = 0; l < k; l++)
                suma += tab[i][j][l];
    return suma;
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3, m = 3, k = 3;
    int*** tab = malloc(n * sizeof(int**));
    for (int i = 0; i < n; i++) {
        tab[i] = malloc(m * sizeof(int*));
        for (int j = 0; j < m; j++) {
            tab[i][j] = malloc(k * sizeof(int));
        }
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            for (int l = 0; l < k; l++)
                tab[i][j][l] = 1;

    printf("Suma: %d\n", suma3D(tab, n, m, k));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            free(tab[i][j]);
        free(tab[i]);
    }
    free(tab);

    return 0;
}



//6.2.15

int suma3D_100x100(int*** tab, int n) {
    int suma = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < 100; j++)
            for (int k = 0; k < 100; k++)
                suma += tab[i][j][k];
    return suma;
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 2;
    int*** tab = malloc(n * sizeof(int**));
    for (int i = 0; i < n; i++) {
        tab[i] = malloc(100 * sizeof(int*));
        for (int j = 0; j < 100; j++) {
            tab[i][j] = malloc(100 * sizeof(int));
        }
    }

    for (int i = 0; i < n; i++)
        for (int j = 0; j < 100; j++)
            for (int k = 0; k < 100; k++)
                tab[i][j][k] = 1;

    printf("Suma: %d\n", suma3D_100x100(tab, n));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 100; j++)
            free(tab[i][j]);
        free(tab[i]);
    }
    free(tab);

    return 0;
}





//6.2.16

int indeksNajwiekszejSredniej(int** tab, int n, int m) {
    int indeks = 0;
    float maxSrednia = -1;

    for (int i = 0; i < n; i++) {
        int suma = 0;
        for (int j = 0; j < m; j++)
            suma += tab[i][j];

        float srednia = (float)suma / m;
        if (srednia > maxSrednia) {
            maxSrednia = srednia;
            indeks = i;
        }
    }

    return indeks;
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3, m = 4;
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++)
        tab[i] = malloc(m * sizeof(int));

    // przykładowe dane
    int dane[3][4] = {
        {1, 2, 3, 4},    // średnia = 2.5
        {5, 5, 5, 5},    // średnia = 5.0
        {1, 1, 1, 1}     // średnia = 1.0
    };

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = dane[i][j];

    int wynik = indeksNajwiekszejSredniej(tab, n, m);
    printf("Indeks wiersza o największej średniej: %d\n", wynik);

    for (int i = 0; i < n; i++)
        free(tab[i]);
    free(tab);

    return 0;
}








//6.2.17

float najwiekszaSrednia(int** tab, int n, int m) {
    float maxSrednia = -1;

    for (int i = 0; i < n; i++) {
        int suma = 0;
        for (int j = 0; j < m; j++)
            suma += tab[i][j];

        float srednia = (float)suma / m;
        if (srednia > maxSrednia)
            maxSrednia = srednia;
    }

    return maxSrednia;
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3, m = 4;
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++)
        tab[i] = malloc(m * sizeof(int));

    int dane[3][4] = {
        {1, 2, 3, 4},    // średnia = 2.5
        {5, 5, 5, 5},    // średnia = 5.0
        {1, 1, 1, 1}     // średnia = 1.0
    };

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = dane[i][j];

    float wynik = najwiekszaSrednia(tab, n, m);
    printf("Największa średnia: %.2f\n", wynik);

    for (int i = 0; i < n; i++)
        free(tab[i]);
    free(tab);

    return 0;
}




\6.2.18

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3, m = 4;
    int** tab = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++)
        tab[i] = malloc(m * sizeof(int));

    // przykładowe dane
    int dane[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 0, 1, 2}
    };

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab[i][j] = dane[i][j];

    wypiszPoKolumnach(tab, n, m);

    for (int i = 0; i < n; i++)
        free(tab[i]);
    free(tab);

    return 0;
}




//6.2.19

void przepiszTablice(int** zrodlo, int** cel, int n, int m) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cel[i][j] = zrodlo[i][j];
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3, m = 4;

    int** tab1 = malloc(n * sizeof(int*));
    int** tab2 = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        tab1[i] = malloc(m * sizeof(int));
        tab2[i] = malloc(m * sizeof(int));
    }

    // wypełniamy tab1
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            tab1[i][j] = i * m + j;

    przepiszTablice(tab1, tab2, n, m);

    // wypisz tab2
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%2d ", tab2[i][j]);
        printf("\n");
    }

    for (int i = 0; i < n; i++) {
        free(tab1[i]);
        free(tab2[i]);
    }
    free(tab1);
    free(tab2);

    return 0;
}





//6.2.20

void zamienTablice(int** a, int** b, int n, int m) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            int temp = a[i][j];
            a[i][j] = b[i][j];
            b[i][j] = temp;
        }
}

// test
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 2, m = 3;

    int** tab1 = malloc(n * sizeof(int*));
    int** tab2 = malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        tab1[i] = malloc(m * sizeof(int));
        tab2[i] = malloc(m * sizeof(int));
    }

    // dane początkowe
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            tab1[i][j] = 1;
            tab2[i][j] = 9;
        }

    zamienTablice(tab1, tab2, n, m);

    // wypisz tablice po zamianie
    printf("tab1:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%d ", tab1[i][j]);
        printf("\n");
    }

    printf("tab2:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%d ", tab2[i][j]);
        printf("\n");
    }

    for (int i = 0; i < n; i++) {
        free(tab1[i]);
        free(tab2[i]);
    }
    free(tab1);
    free(tab2);

    return 0;
}





//7.2.1
#include <stdio.h>

struct trojkat {
    int a, b, c;
};

int obwod(struct trojkat t) {
    return t.a + t.b + t.c;
}

int main() {
    struct trojkat x = {3, 4, 5};
    printf("Obwod trojkata: %d\n", obwod(x));
    return 0;
}





//7.2.2
#include <stdio.h>

struct trojkat {
    int a, b, c;
};

void przepisz(struct trojkat troj1, struct trojkat* troj2) {
    *troj2 = troj1;
}

int main() {
    struct trojkat t1 = {6, 7, 8};
    struct trojkat t2 = {0, 0, 0};

    przepisz(t1, &t2);

    printf("t2 po przepisaniu: %d %d %d\n", t2.a, t2.b, t2.c);
    return 0;
}




//7.2.3
#include <stdio.h>
#include <math.h>

struct punkt {
    float x, y, z;
};

float odleglosc(struct punkt a, struct punkt b) {
    return sqrtf((a.x - b.x)*(a.x - b.x) +
                 (a.y - b.y)*(a.y - b.y) +
                 (a.z - b.z)*(a.z - b.z));
}

float najmniejszaOdleglosc(struct punkt tab[], int n) {
    float min = odleglosc(tab[0], tab[1]);
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++) {
            float d = odleglosc(tab[i], tab[j]);
            if (d < min)
                min = d;
        }
    return min;
}

int main() {
    struct punkt tab[3] = {
        {0.0, 0.0, 0.0},
        {1.0, 1.0, 1.0},
        {0.5, 0.5, 0.5}
    };

    float wynik = najmniejszaOdleglosc(tab, 3);
    printf("Najmniejsza odleglosc: %.3f\n", wynik);

    return 0;
}






//7.2.4
#include <stdio.h>

struct punkt {
    float x, y, z;
};

void przepiszPunkty(struct punkt tab1[], struct punkt tab2[], int n) {
    for (int i = 0; i < n; i++)
        tab2[i] = tab1[i];
}

int main() {
    struct punkt tab1[3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    struct punkt tab2[3];

    przepiszPunkty(tab1, tab2, 3);

    for (int i = 0; i < 3; i++)
        printf("tab2[%d] = (%.1f, %.1f, %.1f)\n", i, tab2[i].x, tab2[i].y, tab2[i].z);

    return 0;
}




//7/2/5
#include <stdio.h>

struct punkt10 {
    float wsp[10];
};

void przepiszPunkty10(struct punkt10 tab1[], struct punkt10 tab2[], int n) {
    for (int i = 0; i < n; i++)
        tab2[i] = tab1[i];
}

int main() {
    struct punkt10 tab1[2] = {
        {{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0}},
        {{1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0}}
    };
    struct punkt10 tab2[2];

    przepiszPunkty10(tab1, tab2, 2);

    for (int i = 0; i < 2; i++) {
        printf("tab2[%d] = ", i);
        for (int j = 0; j < 10; j++)
            printf("%.1f ", tab2[i].wsp[j]);
        printf("\n");
    }

    return 0;
}





//7.2.6

#include <stdio.h>
#include <stdlib.h>

struct punktn {
    int n;         // liczba wymiarów
    float* wsp;    // wskaźnik na tablicę współrzędnych
};

void przepiszPunktyN(struct punktn tab1[], struct punktn tab2[], int ile) {
    for (int i = 0; i < ile; i++) {
        tab2[i].n = tab1[i].n;
        tab2[i].wsp = malloc(tab1[i].n * sizeof(float));
        for (int j = 0; j < tab1[i].n; j++) {
            tab2[i].wsp[j] = tab1[i].wsp[j];
        }
    }
}

int main() {
    int ile = 2;
    struct punktn tab1[2];
    struct punktn tab2[2];

    for (int i = 0; i < ile; i++) {
        tab1[i].n = 3;
        tab1[i].wsp = malloc(3 * sizeof(float));
        for (int j = 0; j < 3; j++) {
            tab1[i].wsp[j] = i + j + 0.5;
        }
    }

    przepiszPunktyN(tab1, tab2, ile);

    for (int i = 0; i < ile; i++) {
        printf("tab2[%d] = ", i);
        for (int j = 0; j < tab2[i].n; j++) {
            printf("%.1f ", tab2[i].wsp[j]);
        }
        printf("\n");
    }

    // free
    for (int i = 0; i < ile; i++) {
        free(tab1[i].wsp);
        free(tab2[i].wsp);
    }

    return 0;
}



7.2.7
#include <stdio.h>

struct zespolone {
    double re;
    double im;
};

struct zespolone dodaj(struct zespolone a, struct zespolone b) {
    struct zespolone wynik;
    wynik.re = a.re + b.re;
    wynik.im = a.im + b.im;
    return wynik;
}

int main() {
    struct zespolone z1 = {2.5, 1.5};
    struct zespolone z2 = {3.0, -2.0};

    struct zespolone suma = dodaj(z1, z2);
    printf("Suma: %.2f + %.2fi\n", suma.re, suma.im);
    return 0;
}


7.2.8
#include <stdio.h>

struct student {
    char imie[20];
    char nazwisko[20];
    char adres[50];
    char pesel[12];
    char kierunek[30];
    int nr_legitymacji;
};

void wczytajStudenta(struct student* s) {
    printf("Podaj imie: ");
    scanf("%s", s->imie);
    printf("Podaj nazwisko: ");
    scanf("%s", s->nazwisko);
    printf("Podaj adres: ");
    scanf("%s", s->adres);
    printf("Podaj PESEL: ");
    scanf("%s", s->pesel);
    printf("Podaj kierunek: ");
    scanf("%s", s->kierunek);
    printf("Podaj nr legitymacji: ");
    scanf("%d", &s->nr_legitymacji);
}

int main() {
    struct student s;
    wczytajStudenta(&s);

    printf("\nStudent: %s %s, PESEL: %s, Kierunek: %s\n", s.imie, s.nazwisko, s.pesel, s.kierunek);
    return 0;
}



7.2.9
#include <stdio.h>

struct lista {
    int dane;
    struct lista* next;
};

int main() {
    struct lista a = {1, NULL};
    struct lista b = {2, NULL};
    a.next = &b;

    printf("a: %d\n", a.dane);
    printf("a.next: %d\n", a.next->dane);

    return 0;
}




//7.2.10
#include <stdio.h>

union super_int {
    int i;
    unsigned int u;
};

int main() {
    union super_int liczba;

    liczba.i = -5;
    printf("Jako int: %d\n", liczba.i);

    liczba.u = 123u;
    printf("Jako unsigned int: %u\n", liczba.u);

    return 0;
}





//7.2.11
#include <stdio.h>

union Liczba {
    int calkowita;
    float wymierna;
};

struct Dane {
    int typ;           // 0 = int, 1 = float
    union Liczba zaw;  // zawartość
};

float wczytajDane() {
    struct Dane d;
    printf("Wczytać liczbę całkowitą (0) czy zmiennoprzecinkową (1)? ");
    scanf("%d", &d.typ);

    if (d.typ == 0) {
        printf("Podaj liczbę całkowitą: ");
        scanf("%d", &d.zaw.calkowita);
        return (float)d.zaw.calkowita;
    } else {
        printf("Podaj liczbę zmiennoprzecinkową: ");
        scanf("%f", &d.zaw.wymierna);
        return d.zaw.wymierna;
    }
}

int main() {
    float wynik = wczytajDane();
    printf("Wczytana liczba: %.2f\n", wynik);
    return 0;
}




//7.2.12

#include <stdio.h>

union Liczba {
    int calkowita;
    float wymierna;
};

struct zespolone {
    int tp; // 0 = int, 1 = float
    union Liczba re;
    union Liczba im;
};

struct zespolone dodaj(struct zespolone z1, struct zespolone z2) {
    struct zespolone wynik;

    // wynik ma być typu float jeśli którykolwiek składnik jest float
    if (z1.tp == 1 || z2.tp == 1) {
        wynik.tp = 1;
        wynik.re.wymierna = 
            (z1.tp == 1 ? z1.re.wymierna : (float)z1.re.calkowita) + 
            (z2.tp == 1 ? z2.re.wymierna : (float)z2.re.calkowita);
        wynik.im.wymierna = 
            (z1.tp == 1 ? z1.im.wymierna : (float)z1.im.calkowita) + 
            (z2.tp == 1 ? z2.im.wymierna : (float)z2.im.calkowita);
    } else {
        wynik.tp = 0;
        wynik.re.calkowita = z1.re.calkowita + z2.re.calkowita;
        wynik.im.calkowita = z1.im.calkowita + z2.im.calkowita;
    }

    return wynik;
}

int main() {
    struct zespolone z1 = {0, {2}, {3}};        // 2 + 3i
    struct zespolone z2 = {1, {.wymierna = 1.5}, {.wymierna = -0.5}}; // 1.5 - 0.5i

    struct zespolone wynik = dodaj(z1, z2);

    if (wynik.tp == 0)
        printf("Wynik: %d + %di\n", wynik.re.calkowita, wynik.im.calkowita);
    else
        printf("Wynik: %.2f + %.2fi\n", wynik.re.wymierna, wynik.im.wymierna);

    return 0;
}




#include <stdio.h>

struct figura {
    int fig;  // 0 = trojkat, 1 = prostokat, 2 = rownoleglobok, 3 = trapez
    union {
        struct { float a, h; } trojkat;
        struct { float a, b; } prostokat;
        struct { float a, h; } rownoleglobok;
        struct { float a, b, h; } trapez;
    } dane;
};

float pole(struct figura f) {
    switch (f.fig) {
        case 0: return (f.dane.trojkat.a * f.dane.trojkat.h) / 2;
        case 1: return f.dane.prostokat.a * f.dane.prostokat.b;
        case 2: return f.dane.rownoleglobok.a * f.dane.rownoleglobok.h;
        case 3: return ((f.dane.trapez.a + f.dane.trapez.b) * f.dane.trapez.h) / 2;
        default: return 0;
    }
}

int main() {
    struct figura f;
    f.fig = 3;
    f.dane.trapez.a = 4;
    f.dane.trapez.b = 6;
    f.dane.trapez.h = 5;

    printf("Pole figury: %.2f\n", pole(f));
    return 0;
}




#include <stdio.h>

enum czworokat { KWADRAT, PROSTOKAT, ROMB, TRAPEZ };

int main() {
    enum czworokat f = TRAPEZ;

    switch (f) {
        case KWADRAT:   printf("Kwadrat\n"); break;
        case PROSTOKAT: printf("Prostokat\n"); break;
        case ROMB:      printf("Romb\n"); break;
        case TRAPEZ:    printf("Trapez\n"); break;
    }

    return 0;
}






#include <stdio.h>

enum zwierzak { KOT, PIES, KROLIK, CHOMIK, RYBKA };

int main() {
    enum zwierzak z = PIES;

    switch (z) {
        case KOT:    printf("To jest kot\n"); break;
        case PIES:   printf("To jest pies\n"); break;
        case KROLIK: printf("To jest królik\n"); break;
        case CHOMIK: printf("To jest chomik\n"); break;
        case RYBKA:  printf("To jest rybka\n"); break;
    }

    return 0;
}





//7.3.1

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* utworz() {
    return NULL;
}

int main() {
    struct element* lista = utworz();
    if (lista == NULL)
        printf("Lista jest pusta (NULL)\n");
    else
        printf("Lista nie jest pusta\n");
    return 0;
}




//7.3.2

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

void wyczysc(struct element* lista) {
    struct element* tmp;
    while (lista != NULL) {
        tmp = lista;
        lista = lista->next;
        free(tmp);
    }
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->a = 1;
    lista->next = malloc(sizeof(struct element));
    lista->next->a = 2;
    lista->next->next = NULL;

    wyczysc(lista);
    printf("Lista została wyczyszczona.\n");
    return 0;
}





//7.3.3

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* dodaj(struct element* Lista, int a) {
    struct element* nowy = malloc(sizeof(struct element));
    nowy->a = a;
    nowy->next = Lista;
    return nowy;
}

int main() {
    struct element* lista = NULL;

    lista = dodaj(lista, 5);
    lista = dodaj(lista, 10);
    lista = dodaj(lista, 20);

    struct element* tmp = lista;
    while (tmp != NULL) {
        printf("%d -> ", tmp->a);
        tmp = tmp->next;
    }
    printf("NULL\n");

    // czyszczenie
    while (lista) {
        struct element* t = lista;
        lista = lista->next;
        free(t);
    }

    return 0;
}




//7.3.4

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* dodaj_k(struct element* Lista, int a) {
    struct element* nowy = malloc(sizeof(struct element));
    nowy->a = a;
    nowy->next = NULL;

    if (Lista == NULL)
        return nowy;

    struct element* tmp = Lista;
    while (tmp->next != NULL)
        tmp = tmp->next;

    tmp->next = nowy;
    return Lista;
}

int main() {
    struct element* lista = NULL;

    lista = dodaj_k(lista, 1);
    lista = dodaj_k(lista, 2);
    lista = dodaj_k(lista, 3);

    for (struct element* p = lista; p; p = p->next)
        printf("%d -> ", p->a);
    printf("NULL\n");

    // free
    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}




//7.3.5

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* dodaj_w(struct element* Lista, struct element* elem, int a) {
    struct element* nowy = malloc(sizeof(struct element));
    nowy->a = a;

    if (elem == NULL) {
        nowy->next = Lista;
        return nowy;
    }

    nowy->next = elem->next;
    elem->next = nowy;
    return Lista;
}

int main() {
    struct element* lista = NULL;
    lista = dodaj_w(lista, NULL, 1);            // na początek
    lista = dodaj_w(lista, lista, 2);           // po pierwszym
    lista = dodaj_w(lista, lista->next, 3);     // po drugim

    for (struct element* p = lista; p; p = p->next)
        printf("%d -> ", p->a);
    printf("NULL\n");

    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}




//7.3.6

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* znajdz(struct element* Lista, int n) {
    while (Lista != NULL) {
        if (Lista->a == n)
            return Lista;
        Lista = Lista->next;
    }
    return NULL;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->a = 1;
    lista->next = malloc(sizeof(struct element));
    lista->next->a = 7;
    lista->next->next = NULL;

    struct element* wynik = znajdz(lista, 7);
    if (wynik)
        printf("Znaleziono: %d\n", wynik->a);
    else
        printf("Nie znaleziono\n");

    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}




//7.3.7

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* usun(struct element* Lista, int wartosc) {
    struct element* prev = NULL;
    struct element* curr = Lista;

    while (curr != NULL) {
        if (curr->a == wartosc) {
            if (prev == NULL) {
                struct element* next = curr->next;
                free(curr);
                return next;
            } else {
                prev->next = curr->next;
                free(curr);
                return Lista;
            }
        }
        prev = curr;
        curr = curr->next;
    }

    return Lista;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->a = 1;
    lista->next = malloc(sizeof(struct element));
    lista->next->a = 2;
    lista->next->next = NULL;

    lista = usun(lista, 2);

    for (struct element* p = lista; p; p = p->next)
        printf("%d -> ", p->a);
    printf("NULL\n");

    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}




//7.3.8

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* usun_wsk(struct element* Lista, struct element* elem) {
    if (elem == NULL) return Lista;

    struct element* prev = NULL;
    struct element* curr = Lista;

    while (curr != NULL) {
        if (curr == elem) {
            if (prev == NULL) {
                struct element* next = curr->next;
                free(curr);
                return next;
            } else {
                prev->next = curr->next;
                free(curr);
                return Lista;
            }
        }
        prev = curr;
        curr = curr->next;
    }

    return Lista;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->a = 1;
    lista->next = malloc(sizeof(struct element));
    lista->next->a = 2;
    lista->next->next = NULL;

    struct element* do_usuniecia = lista->next;
    lista = usun_wsk(lista, do_usuniecia);

    for (struct element* p = lista; p; p = p->next)
        printf("%d -> ", p->a);
    printf("NULL\n");

    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}




//7.3.10

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* utworz() {
    struct element* glowa = malloc(sizeof(struct element));
    glowa->next = NULL;
    return glowa;
}

int main() {
    struct element* lista = utworz();
    if (lista && lista->next == NULL)
        printf("Utworzono pustą listę z głową.\n");
    free(lista);
    return 0;
}




//7.3.11

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

void wyczysc(struct element* lista) {
    struct element* p = lista->next;
    struct element* tmp;
    while (p != NULL) {
        tmp = p;
        p = p->next;
        free(tmp);
    }
    lista->next = NULL;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->next = malloc(sizeof(struct element));
    lista->next->a = 1;
    lista->next->next = NULL;

    wyczysc(lista);
    printf("Lista wyczyszczona.\n");

    free(lista);
    return 0;
}




//7.3.12

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* dodaj_poczatek(struct element* Lista, int a) {
    struct element* nowy = malloc(sizeof(struct element));
    nowy->a = a;
    nowy->next = Lista->next;
    Lista->next = nowy;
    return Lista;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->next = NULL;

    dodaj_poczatek(lista, 3);
    dodaj_poczatek(lista, 2);
    dodaj_poczatek(lista, 1);

    for (struct element* p = lista->next; p; p = p->next)
        printf("%d -> ", p->a);
    printf("NULL\n");

    // czyszczenie
    struct element* p = lista;
    while (p) {
        struct element* tmp = p;
        p = p->next;
        free(tmp);
    }

    return 0;
}





//7.3.13

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* dodaj_koniec(struct element* Lista, int a) {
    struct element* nowy = malloc(sizeof(struct element));
    nowy->a = a;
    nowy->next = NULL;

    struct element* p = Lista;
    while (p->next != NULL)
        p = p->next;

    p->next = nowy;
    return Lista;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->next = NULL;

    dodaj_koniec(lista, 10);
    dodaj_koniec(lista, 20);
    dodaj_koniec(lista, 30);

    for (struct element* p = lista->next; p; p = p->next)
        printf("%d -> ", p->a);
    printf("NULL\n");

    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}






//7.3.14

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* dodaj_wsk(struct element* Lista, struct element* elem, int a) {
    struct element* nowy = malloc(sizeof(struct element));
    nowy->a = a;

    if (elem == NULL) {
        nowy->next = Lista->next;
        Lista->next = nowy;
    } else {
        nowy->next = elem->next;
        elem->next = nowy;
    }

    return Lista;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->next = NULL;

    dodaj_wsk(lista, NULL, 1);             // na początek
    dodaj_wsk(lista, lista->next, 2);      // po 1
    dodaj_wsk(lista, lista->next->next, 3); // po 2

    for (struct element* p = lista->next; p; p = p->next)
        printf("%d -> ", p->a);
    printf("NULL\n");

    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}




//7.3.15

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* znajdz(struct element* Lista, int i) {
    struct element* p = Lista->next;
    while (p != NULL) {
        if (p->a == i)
            return p;
        p = p->next;
    }
    return NULL;
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->next = malloc(sizeof(struct element));
    lista->next->a = 5;
    lista->next->next = malloc(sizeof(struct element));
    lista->next->next->a = 9;
    lista->next->next->next = NULL;

    struct element* znaleziony = znajdz(lista, 9);
    if (znaleziony)
        printf("Znaleziono element: %d\n", znaleziony->a);
    else
        printf("Nie znaleziono elementu\n");

    // free
    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}





//7.3.16

#include <stdio.h>
#include <stdlib.h>

struct element {
    int a;
    struct element* next;
};

struct element* znajdzp(struct element* Lista, int i) {
    struct element* p = Lista;
    while (p->next != NULL) {
        if (p->next->a == i)
            return p;
        p = p->next;
    }
    return p; // ostatni element
}

int main() {
    struct element* lista = malloc(sizeof(struct element));
    lista->next = malloc(sizeof(struct element));
    lista->next->a = 3;
    lista->next->next = malloc(sizeof(struct element));
    lista->next->next->a = 8;
    lista->next->next->next = NULL;

    struct element* wynik = znajdzp(lista, 8);
    if (wynik->next)
        printf("Znaleziono poprzednik elementu %d: %d\n", wynik->next->a, wynik->a);
    else
        printf("Zwrócono ostatni element (nie znaleziono)\n");

    // free
    while (lista) {
        struct element* tmp = lista;
        lista = lista->next;
        free(tmp);
    }

    return 0;
}

